# reading the downloaded files
pdf_path <- paste0(getwd(),'/web_results/')
pdf_files <- list.files(path = pdf_path, pattern = ".pdf$",  full.names = FALSE)
# removing the files smaller than 10 KB
pdf_size <- list.files(path = pdf_path, pattern = ".pdf$",  full.names = TRUE)
files_keep <- pdf_size[sapply(pdf_size, file.size) > 10000]
all_files <- list.files(path = pdf_path, full.names = TRUE)
files_remove <- all_files[-pmatch(files_keep,all_files)]
for (i in files_remove){
if (file.exists(i)) {
file.remove(i)
}
}
# reading all pdf files afresh
pdf_files <- list.files(path = pdf_path, pattern = ".pdf$",  full.names = FALSE)
# splitting the file names to seperate ids and file names
file_split <- stri_split_fixed(pdf_files, "#$")
ids <- vector(mode="character")
files <- vector(mode="character")
for (i in 1:length(file_split)){
id_l <- file_split[[i]][1]
file_l <- file_split[[i]][2]
# appending both things to the initialized vectors
ids <- append(ids, id_l)
files <- append(files, file_l)
}
# for every query we assign associated files
unique_ids <- (unique(ids))
unique_files <- unique(files)
# attaching queries to ids
unique_queries <- vector(mode="character")
for (i in unique_ids){
num_id <- as.integer(str_split(i, "_")[[1]][2])
curr_ele <- as.character(url_file$urls[num_id])
unique_queries <- append(unique_queries, curr_ele)
}
queries <- vector(mode="character")
for (i in ids){
num_id <- as.integer(str_split(i, "_")[[1]][2])
curr_ele <- as.character(url_file$urls[num_id])
queries <- append(queries, curr_ele)
}
# detecting duplicate downloaded files (if any)
for (i in 1:length(unique_queries)){
assign(paste0('query',i), unique_queries[i])
match_indexes <- which(queries %in% get(paste0('query',i)))
assign(paste0('file',i), files[min(match_indexes):max(match_indexes)])
assign(paste0('vec_',i), vector())
}
# for every unique file, does it appear for the query?
for (i in 1:length(unique_files)){
curr_file <- unique_files[i]
# going through all files
for (j in 1:length(unique_queries))
{
assign(paste0('present',j), (curr_file %in% get(paste0('file',j))))
temp_flag <- append(get(paste0('vec_',j)), get(paste0('present',j)))
assign(paste0('vec_',j), temp_flag*1)
}
}
# creating a matrix to indicate if a file is attached to a query
# creating a data frame with the requisite information
# initializing the data frame with the first query results
df <- as.data.frame(cbind(unique_files, vec_1))
# renaming the column for the added query result
names(df)[2] <- query1
for (i in 2:length(unique_queries)){
# adding the subsequent columns
df <- cbind(df, get(paste0('vec_',i)))
# renaming the columns
names(df)[i+1] <- get(paste0('query',i))
}
# cleaning up the downloaded files
# create a new folder (unique_files)
unlink("unique_files", recursive = TRUE)
dir.create("unique_files")
# copying files to the new location
file.copy(file.path(pdf_path, pdf_files), paste0(getwd(),"/unique_files"))
# keeping only the unique files
old_names <- list.files(paste0(getwd(),"/unique_files"), full.names = FALSE)
# splitting the file names to seperate file name and file names
file_split <- stri_split_fixed(old_names, "#$")
new_names <- vector(mode="character")
unq_file_names <- vector(mode="character")
for (i in 1:length(file_split)){
file_l <- file_split[[i]][2]
# appending both things to the initialized vectors
new_names <- append(new_names, file_l)
}
# "uniqueify" the files in the directory
file.rename(from = file.path(paste0(getwd(),"/unique_files"), old_names), to = file.path(paste0(getwd(),"/unique_files"), new_names))
# remove the web results folder
unlink("web_results", recursive = TRUE)
# prioritize the resultant dataframe
temp_df <- df
temp_df$unique_files <- NULL
# converting all columns into numeric
num_col <- dim(temp_df)[2]
for (i in 1:num_col){
temp_df[,i] <- as.numeric(as.character(temp_df[,i]))
}
# sorting documents (appear most queries)
sum_rows <- rowSums(temp_df)
df$commonality <- sum_rows
df <- df[order(-df$commonality),]
df$commonality <- NULL
wb <- createWorkbook()
sheet_num = 1
addWorksheet(wb = wb)
writeDataTable(wb = wb, sheet = sheet_num, x = df)
packages <- c("rvest", "stringi", "stringr", "downloader", "insol","openxlsx")
if (length(setdiff(packages, rownames(installed.packages()))) > 0) {
install.packages(setdiff(packages, rownames(installed.packages())))
}
brary(openxlsx)
library(openxlsx)
# writing the xlsx
wb <- createWorkbook()
sheet_num = 1
addWorksheet(wb = wb)
writeDataTable(wb = wb, sheet = sheet_num, x = df)
saveWorkbook(wb, paste0(fname,".xlsx"), overwrite = TRUE)
fname = 'pdfs_extracted'
wb <- createWorkbook()
sheet_num = 1
addWorksheet(wb = wb, sheetName = 'Sheet1')
writeDataTable(wb = wb, sheet = sheet_num, x = df)
saveWorkbook(wb, paste0(fname,".xlsx"), overwrite = TRUE)
# setting working directory
setwd('//netid.washington.edu/wfs/EvansEPAR/Project/EPAR/Working Files/372 - EPAR Tools Development/_TOOLS_Main_Folder/file_rename_OPP/test')
# provide regex pattern to identify relevant parent folders by their folder names
pattern = "*OPP*"
# current working directory
mydir <- getwd()
# gets name of all parent folders to copy name from
# name should contain a pattern OPP
subfolders <- grep(pattern, list.dirs(mydir, full.names = TRUE, recursive = FALSE), value = TRUE)
# defining the function to rename all files
renameFunc <- function(z){
setwd(z)
# reading all the files within a folder
list_files <- list.files(recursive = TRUE)
append_name <- substr(z, nchar(mydir)+2, nchar(z))
print (paste0('All files in the folder ',append_name,' being renamed...'))
# going through all the files in a directory
for (i in 1:length(list_files)){
# treating a certain file
curr_file <- list_files[i]
# splitting the file path on backslash
str_split <- strsplit(curr_file, split='/', fixed = TRUE)
# length of the split
len_split <- length(str_split[[1]])
# last part is the file_name
file_name <- str_split[[1]][len_split]
# length of split > 1?
if (len_split == 1){
rel_path = ""
}
else{
# relative path of the file
rel_path <- str_split[[1]][1]
if (len_split > 2){
for (j in 2:(len_split-1)){
path <- str_split[[1]][j]
rel_path <- paste0(rel_path, "/", path)
}
}
}
# new name assignment
# if the prefix is not OPP
prefix <- "OPP"
first_3letters <- substr(file_name, 1, 3)
if (first_3letters != prefix){
new_name <- paste0(append_name, "_", file_name)
if (rel_path == "")
{
# renaming the file
file.rename(from = curr_file, to = new_name)
}
else {
full_new_name <- paste0(rel_path , "/", new_name)
# renaming the file
file.rename(from = curr_file, to = full_new_name)
}
}
}
}
# applying the renaming function
invisible(lapply(subfolders, renameFunc))
# pattern = "*" to treat all files as parent folders; no particular identifying pattern
pattern = "*OPP*"
# current working directory
mydir <- getwd()
# gets name of all parent folders to copy name from
# name should contain a pattern OPP
subfolders <- grep(pattern, list.dirs(mydir, full.names = TRUE, recursive = FALSE), value = TRUE)
# defining the function to rename all files
renameFunc <- function(z){
setwd(z)
# reading all the files within a folder
list_files <- list.files(recursive = TRUE)
append_name <- substr(z, nchar(mydir)+2, nchar(z))
print (paste0('All files in the folder ',append_name,' being renamed...'))
# going through all the files in a directory
for (i in 1:length(list_files)){
# treating a certain file
curr_file <- list_files[i]
# splitting the file path on backslash
str_split <- strsplit(curr_file, split='/', fixed = TRUE)
# length of the split
len_split <- length(str_split[[1]])
# last part is the file_name
file_name <- str_split[[1]][len_split]
# length of split > 1?
if (len_split == 1){
rel_path = ""
}
else{
# relative path of the file
rel_path <- str_split[[1]][1]
if (len_split > 2){
for (j in 2:(len_split-1)){
path <- str_split[[1]][j]
rel_path <- paste0(rel_path, "/", path)
}
}
}
# new name assignment
# if the prefix is not OPP
prefix <- "OPP"
first_3letters <- substr(file_name, 1, 3)
if (first_3letters != prefix){
new_name <- paste0(append_name, "_", file_name)
if (rel_path == "")
{
# renaming the file
file.rename(from = curr_file, to = new_name)
}
else {
full_new_name <- paste0(rel_path , "/", new_name)
# renaming the file
file.rename(from = curr_file, to = full_new_name)
}
}
}
}
# applying the renaming function
invisible(lapply(subfolders, renameFunc))
#clear workspace
rm(list = ls())
# setting working directory
setwd('//netid.washington.edu/wfs/EvansEPAR/Project/EPAR/Working Files/372 - EPAR Tools Development/_TOOLS_Main_Folder/file_rename_OPP/test')
# provide regex pattern to identify relevant parent folders by their folder names
# pattern = "*" to treat all files as parent folders; no particular identifying pattern
pattern = "*OPP*"
# current working directory
mydir <- getwd()
# gets name of all parent folders to
subfolders <- grep(pattern, list.dirs(mydir, full.names = TRUE, recursive = FALSE), value = TRUE)
# defining the function to rename all files
renameFunc <- function(z){
setwd(z)
# reading all the files within a folder
list_files <- list.files(recursive = TRUE)
append_name <- substr(z, nchar(mydir)+2, nchar(z))
print (paste0('All files in the folder ',append_name,' being renamed...'))
# going through all the files in a directory
for (i in 1:length(list_files)){
# treating a certain file
curr_file <- list_files[i]
# splitting the file path on backslash
str_split <- strsplit(curr_file, split='/', fixed = TRUE)
# length of the split
len_split <- length(str_split[[1]])
# last part is the file_name
file_name <- str_split[[1]][len_split]
# length of split > 1?
if (len_split == 1){
rel_path = ""
}
else{
# relative path of the file
rel_path <- str_split[[1]][1]
if (len_split > 2){
for (j in 2:(len_split-1)){
path <- str_split[[1]][j]
rel_path <- paste0(rel_path, "/", path)
}
}
}
# new name assignment
# if the prefix is not OPP
prefix <- "OPP"
first_3letters <- substr(file_name, 1, 3)
if (first_3letters != prefix){
new_name <- paste0(append_name, "_", file_name)
if (rel_path == "")
{
# renaming the file
file.rename(from = curr_file, to = new_name)
}
else {
full_new_name <- paste0(rel_path , "/", new_name)
# renaming the file
file.rename(from = curr_file, to = full_new_name)
}
}
}
}
# applying the renaming function
invisible(lapply(subfolders, renameFunc))
rm(list = ls())
# setting working directory
setwd('//netid.washington.edu/wfs/EvansEPAR/Project/EPAR/Working Files/372 - EPAR Tools Development/_TOOLS_Main_Folder/file_rename_OPP/test')
# provide regex pattern to identify relevant parent folders by their folder names
# pattern = "*" to treat all files as parent folders; no particular identifying pattern
pattern="*"
############################################################################
# current working directory
mydir <- getwd()
# gets name of all parent folders to copy name from
# name should contain a pattern OPP
subfolders <- grep(pattern, list.dirs(mydir, full.names = TRUE, recursive = FALSE), value = TRUE)
# defining the function to rename all files
renameFunc <- function(z){
setwd(z)
# reading all the files within a folder
list_files <- list.files(recursive = TRUE)
append_name <- substr(z, nchar(mydir)+2, nchar(z))
print (paste0('All files in the folder ',append_name,' being renamed...'))
# going through all the files in a directory
for (i in 1:length(list_files)){
# treating a certain file
curr_file <- list_files[i]
# splitting the file path on backslash
str_split <- strsplit(curr_file, split='/', fixed = TRUE)
# length of the split
len_split <- length(str_split[[1]])
# last part is the file_name
file_name <- str_split[[1]][len_split]
# length of split > 1?
if (len_split == 1){
rel_path = ""
}
else{
# relative path of the file
rel_path <- str_split[[1]][1]
if (len_split > 2){
for (j in 2:(len_split-1)){
path <- str_split[[1]][j]
rel_path <- paste0(rel_path, "/", path)
}
}
}
# new name assignment
# if the prefix is not OPP
prefix <- "OPP"
first_3letters <- substr(file_name, 1, 3)
if (first_3letters != prefix){
new_name <- paste0(append_name, "_", file_name)
if (rel_path == "")
{
# renaming the file
file.rename(from = curr_file, to = new_name)
}
else {
full_new_name <- paste0(rel_path , "/", new_name)
# renaming the file
file.rename(from = curr_file, to = full_new_name)
}
}
}
}
# applying the renaming function
invisible(lapply(subfolders, renameFunc))
list_files
list_files <- list.files(recursive = TRUE)
list_files
# Purpose of script: This script was developed by the Evans School Policy Analysis & Research Group (EPAR) to update the names of files in a directory based on the name of their parent folder. The script will recursively enter all folders within a folder as-needed. The initial use case was appending the grant number to the set of files shared for that grant.
# Date: 2 May 2019
# Inputs: N/A
# Outputs: N/A
############# define the folder where parent folder(s) whose name(s) will be used to rename subfiles reside ##########################
# clear workspace
rm(list = ls())
# setting working directory
setwd('//netid.washington.edu/wfs/EvansEPAR/Project/EPAR/Working Files/372 - EPAR Tools Development/_TOOLS_Main_Folder/file_rename_OPP/test')
# provide regex pattern to identify relevant parent folders by their folder names
# pattern = "*" to treat all files as parent folders; no particular identifying pattern
pattern = "*OPP*"
###################################################################################
# current working directory
mydir <- getwd()
# gets name of all parent folders to copy name from
# name should contain a pattern OPP
subfolders <- grep(pattern, list.dirs(mydir, full.names = TRUE, recursive = FALSE), value = TRUE)
# defining the function to rename all files
renameFunc <- function(z){
setwd(z)
# reading all the files within a folder
list_files <- list.files(recursive = TRUE)
append_name <- substr(z, nchar(mydir)+2, nchar(z))
print (paste0('All files in the folder ',append_name,' being renamed...'))
# going through all the files in a directory
for (i in 1:length(list_files)){
# treating a certain file
curr_file <- list_files[i]
# splitting the file path on backslash
str_split <- strsplit(curr_file, split='/', fixed = TRUE)
# length of the split
len_split <- length(str_split[[1]])
# last part is the file_name
file_name <- str_split[[1]][len_split]
# length of split > 1?
if (len_split == 1){
rel_path = ""
}
else{
# relative path of the file
rel_path <- str_split[[1]][1]
if (len_split > 2){
for (j in 2:(len_split-1)){
path <- str_split[[1]][j]
rel_path <- paste0(rel_path, "/", path)
}
}
}
# new name assignment
# if the prefix is not OPP
prefix <- "OPP"
first_3letters <- substr(file_name, 1, 3)
if (first_3letters != prefix){
new_name <- paste0(append_name, "_", file_name)
if (rel_path == "")
{
# renaming the file
file.rename(from = curr_file, to = new_name)
}
else {
full_new_name <- paste0(rel_path , "/", new_name)
# renaming the file
file.rename(from = curr_file, to = full_new_name)
}
}
}
}
# applying the renaming function
invisible(lapply(subfolders, renameFunc))
# Purpose of script: This script was developed by the Evans School Policy Analysis & Research Group (EPAR) to update the names of files in a directory based on the name of their parent folder. The script will recursively enter all folders within a folder as-needed. The initial use case was appending the grant number to the set of files shared for that grant.
# Date: 2 May 2019
# Inputs: N/A
# Outputs: N/A
############# define the folder where parent folder(s) whose name(s) will be used to rename subfiles reside ##########################
#clear workspace
rm(list = ls())
# setting working directory
setwd('//netid.washington.edu/wfs/EvansEPAR/Project/EPAR/Working Files/372 - EPAR Tools Development/_TOOLS_Main_Folder/file_rename_OPP/test2')
# provide regex pattern to identify relevant parent folders by their folder names
pattern="*"
###################################################################################
# current working directory
mydir <- getwd()
# gets name of all parent folders to copy name from
# name should contain a pattern OPP
subfolders <- grep(pattern, list.dirs(mydir, full.names = TRUE, recursive = FALSE), value = TRUE)
# defining the function to rename all files
renameFunc <- function(z){
setwd(z)
# reading all the files within a folder
list_files <- list.files(recursive = TRUE)
append_name <- substr(z, nchar(mydir)+2, nchar(z))
print (paste0('All files in the folder ',append_name,' being renamed...'))
# going through all the files in a directory
for (i in 1:length(list_files)){
# treating a certain file
curr_file <- list_files[i]
# splitting the file path on backslash
str_split <- strsplit(curr_file, split='/', fixed = TRUE)
# length of the split
len_split <- length(str_split[[1]])
# last part is the file_name
file_name <- str_split[[1]][len_split]
# length of split > 1?
if (len_split == 1){
rel_path = ""
}
else{
# relative path of the file
rel_path <- str_split[[1]][1]
if (len_split > 2){
for (j in 2:(len_split-1)){
path <- str_split[[1]][j]
rel_path <- paste0(rel_path, "/", path)
}
}
}
# new name assignment
new_name <- paste0(append_name, "_", file_name)
if (rel_path == "")
{
# renaming the file
file.rename(from = curr_file, to = new_name)
}
else {
full_new_name <- paste0(rel_path , "/", new_name)
# renaming the file
file.rename(from = curr_file, to = full_new_name)
}
}
}
# applying the renaming function
invisible(lapply(subfolders, renameFunc))
